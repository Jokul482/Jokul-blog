import{_ as s,c as i,b as a,o as t}from"./app-D0nffr2b.js";const n={};function l(o,e){return t(),i("div",null,e[0]||(e[0]=[a(`<p><strong>又名：在浏览器输入URL回车之后发生了什么？</strong></p><p>要搞懂浏览器渲染原理，咱得先瞅瞅浏览器。</p><ul><li>Chrome</li><li>Safari</li><li>Edge</li><li>Firefox</li><li>Samsung Internet</li><li>Opera</li></ul><p>如今市面上，这六位可算是浏览器界的模范儿！</p><p>好，现在咱假设一下，要是某天，你心血来潮，想在网上瞅瞅重庆山城的美景，刷一下<code>www.baidu.com</code>。手机掏出来，浏览器打开，网址栏一敲，回车，然后，接下来会发生啥呢？</p><p>别急，这个过程其实可复杂啦，要是简化一下的话，大致是这样的几步：</p><p><code>输入 URL → DNS 解析 → 建立 TCP 连接 → 发送 HTTP 请求 → 服务器响应 → 下载资源 → 解析 HTML → 构建 DOM/CSSOM → 执行 JS → 生成渲染树 → 布局（Layout） → 绘制（Paint）</code></p><p>乍一看，这每一小步都藏着不少门道。比如，<code>DNS</code>、<code>TCP</code>、<code>HTTP</code>，这些词儿，你是不是觉得挺眼熟，但又不知道它们到底干啥的？还有 <code>CSSOM</code> 以及 <code>渲染树</code>，这两个词儿更是听得人一脸懵，不知所云。</p><p>咱就从第一步开始，慢慢唠唠。</p><div class="hint-container tip"><p class="hint-container-title">说明</p><p>2025年1月，<a href="https://gs.statcounter.com/" target="_blank" rel="noopener noreferrer">Statcounter Global Stats - Browser</a>显示。</p><p><strong>Chrome</strong>一马当先占了 <strong>67.08%</strong>，也难怪现如今搞前端开发的，<code>Chrome</code>调试工具几乎成了“必需品”；</p><p><strong>Safari</strong>呢，<strong>17.95%</strong> 的占比，苹果生态的老铁们（大部分要用它）。</p><p><strong>Edge</strong>，占比 <strong>5.2%</strong>。“Chromium系”的一员，拥有强大兼容性和性能。</p><p><strong>Firefox</strong>，占比 <strong>2.54%</strong>。开源界的“大拿”，虽市场份额不高，但在开发者圈里，因其强大的隐私保护和扩展功能，一直有不少拥趸。</p><p><strong>Samsung Internet</strong>，占比<strong>2.24%</strong>。<code>Samsung Internet</code> 针对三星手机和平板进行了深度优化。</p><p><strong>Opera</strong>，占比<strong>2.11%</strong>。<code>Opera</code> 浏览器以轻量级著称，启动速度快，资源占用低，适合在性能较弱的设备上使用。</p></div><h2 id="第一步-输入-url-浏览器开始dns解析" tabindex="-1"><a class="header-anchor" href="#第一步-输入-url-浏览器开始dns解析"><span>第一步：输入 URL，浏览器开始DNS解析</span></a></h2><p><em>你好奇地问道：&quot;当我在浏览器输入网址后，它究竟是如何找到对应网站的呢？&quot;</em></p><p><em>&quot;这就要从互联网的&#39;电话簿&#39;——DNS解析说起了。&quot;</em></p><p>当你在浏览器输入 <code>www.baidu.com</code> 时，浏览器需要借助<code>DNS</code>（域名系统）将人类友好的域名转换为机器识别的<code>IP</code>地址（如 <code>14.215.177.38</code>）。</p><blockquote><h3 id="为什么需要dns解析" tabindex="-1"><a class="header-anchor" href="#为什么需要dns解析"><span>为什么需要DNS解析？</span></a></h3></blockquote><ul><li>人类擅长记忆语义化名称（如<code>www.baidu.com</code>），而网络设备依赖数字IP地址进行通信。</li><li>IP地址可能变更（服务器迁移/扩容），域名保持不变。</li><li>负载均衡：一个域名可映射多个IP（如百度实际对应数万台服务器）</li><li>虚拟主机：通过HTTP头中的Host字段区分同一IP的不同网站</li></ul><blockquote><h3 id="为什么不用ip直接访问" tabindex="-1"><a class="header-anchor" href="#为什么不用ip直接访问"><span>为什么不用IP直接访问？</span></a></h3></blockquote><ul><li>记忆成本：记住<code>220.181.38.148</code>不如<code>baidu.com</code>方便</li><li>灵活性：IP变更无需用户感知</li><li>安全性：DNS支持DNSSEC防劫持，HTTPS确保传输加密</li></ul><blockquote><h3 id="dns解析的完整流程" tabindex="-1"><a class="header-anchor" href="#dns解析的完整流程"><span>DNS解析的完整流程</span></a></h3></blockquote><ol><li>浏览器缓存 → 2. 系统缓存 → 3. 路由器缓存 → 4. ISP DNS缓存 → 5. 递归查询 （若所有缓存未命中，最终会访问根域名服务器→顶级域名服务器→权威域名服务器）</li></ol><p>▶ 比喻版解释：<br> 就像找人问路时，先问同桌（浏览器缓存）→ 班长（系统缓存）→ 班主任（路由器）→ 教务处（ISP）→ 最终查到学籍档案室（根域名服务器）</p><div class="hint-container tip"><p class="hint-container-title">总结</p><p>DNS 的这一转换过程是浏览器开始渲染页面的第一步，是互联网基础架构中的关键环节，确保了人类能够以直观且高效的方式使用网络资源。</p></div><h2 id="第二步-建立-tcp-连接" tabindex="-1"><a class="header-anchor" href="#第二步-建立-tcp-连接"><span>第二步：建立 TCP 连接</span></a></h2><p><strong>TCP（Transmission Control Protocol，传输控制协议）就是一种面向连接的、可靠的、基于字节流的传输层通信协议。建立 TCP 连接，就是通过三次握手建立可靠的连接。</strong></p><p>“也就是说当浏览器完成 <code>DNS</code> 解析并获取目标服务器的 IP 地址后，接下来会进入建立 <code>TCP</code> 连接的阶段。而建立 <code>TCP</code> 连接发生的具体过程，通常称为“三次握手”（<strong>Three-Way Handshake</strong>）”</p><p><em>“你明白了吗？”我微微一笑道。</em></p><p><em>“嗯，有点懂了。建立 <code>TCP</code> 连接会发生三次握手。<strong>那为啥要三次握手呢？不能握一次吗？三次握手成功或者失败又会发生什么呢？</strong>“你不解的问。</em></p><p><em>“我给你简单解释一下。”</em></p><blockquote><h3 id="为什么要进行三次握手" tabindex="-1"><a class="header-anchor" href="#为什么要进行三次握手"><span>为什么要进行三次握手？</span></a></h3></blockquote><ol><li>确保双方都准备好：三次握手确保双方都有收发信息的能力，且都愿意建立连接。</li></ol><ul><li>第一次握手（SYN）： 客户端发送 <code>SYN</code> 给服务器，告诉服务器它想建立连接，并提供一个初始序列号。</li><li>第二次握手（SYN-ACK）： 服务器收到 <code>SYN</code> 后，确认客户端的存在，并且也准备好建立连接，同时提供自己的初始序列号。</li><li>第三次握手（ACK）： 客户端收到 <code>SYN-ACK</code> 后，确认服务器的存在，并且告诉服务器它已经准备好接收数据。</li></ul><ol start="2"><li>防止无效连接：能避免旧的或重复的连接请求在网络中游荡而建立无效连接，保障通信稳定。</li></ol><ul><li>三次握手可以防止旧的连接请求数据包意外地建立连接。例如，客户端可能发送了一个 <code>SYN</code>，但因为网络延迟或丢包，这个 <code>SYN</code> 很久之后才到达服务 器。如果只有一次握手，服务器可能会误以为这是一个新的连接请求，从而建立一个无效的连接。</li><li>通过三次握手，服务器可以通过确认号<code>（Ack）</code>来验证客户端是否是真正想要建立连接的，而不是一个旧的请求。</li></ul><blockquote><h3 id="不能握一次手吗" tabindex="-1"><a class="header-anchor" href="#不能握一次手吗"><span>不能握一次手吗？</span></a></h3></blockquote><p>如果只有一次握手，比如客户端发送一个 <code>SYN</code>，服务器收到后直接开始发送数据，那么可能会出现以下问题：</p><ul><li>客户端可能因为网络问题没有收到服务器的响应，导致客户端不知道服务器是否准备好。</li><li>服务器可能因为网络问题没有收到客户端的 <code>SYN</code>，导致服务器不知道客户端是否准备好。</li></ul><p><strong>所以，一次握手无法确认双方的收发能力与连接意愿。</strong></p><blockquote><h3 id="三次握手成功或者失败又会发生什么呢" tabindex="-1"><a class="header-anchor" href="#三次握手成功或者失败又会发生什么呢"><span>三次握手成功或者失败又会发生什么呢？</span></a></h3></blockquote><p><strong>成功</strong></p><ul><li>连接建立：三次握手成功后，双方进入“已建立”状态，可正常传输数据，进行网页加载等操作。</li></ul><p><strong>失败</strong></p><ul><li>超时重传： 若发送方在规定时间内无响应，会重传信号，多次失败则提示“无法连接”。</li><li>拒绝连接： 服务器因故障或资源不足，发送 <code>RST</code> 数据包，告知连接失败。</li><li>未收到 ACK： 服务器重发 <code>SYN-ACK</code> 若仍无回应，释放资源，连接失败。</li></ul><div class="hint-container tip"><p class="hint-container-title">总结</p><p>三次握手是 TCP 协议中确保连接可靠性和双方准备状态的重要机制。通过三次握手，可以有效防止无效连接，确保双方都准备好进行数据传输。虽然看起来有些复杂，但这是为了保证网络通信的稳定性和可靠性。</p></div><h2 id="第三步-发送-http-请求" tabindex="-1"><a class="header-anchor" href="#第三步-发送-http-请求"><span>第三步：发送 HTTP 请求</span></a></h2><p><em>“接下来就要回答你之前问的问题啦”我微笑着给你说。</em></p><blockquote><h3 id="什么是-http-请求" tabindex="-1"><a class="header-anchor" href="#什么是-http-请求"><span>什么是 HTTP 请求？</span></a></h3></blockquote><ul><li><code>HTTP</code>（超文本传输协议）是浏览器和服务器之间通信的标准协议。当浏览器需要从服务器获取资源（如网页、图片、<code>CSS</code>文件等）时，就会发送 <code>HTTP</code> 请求。<code>HTTP</code> 请求是一种消息格式，它包含请求行、请求头和请求体。</li></ul><blockquote><h3 id="http-请求的作用" tabindex="-1"><a class="header-anchor" href="#http-请求的作用"><span>HTTP 请求的作用?</span></a></h3></blockquote><ul><li><strong>获取资源：</strong> 浏览器通过发送 <code>HTTP</code> 请求向服务器请求特定的资源，例如网页的 <code>HTML</code> 文件、图片、<code>JavaScript</code> 文件或 <code>CSS</code> 文件。</li><li><strong>发送数据：</strong> 用户在浏览器中提交表单（如搜索查询、登录信息等）时，浏览器会通过 <code>HTTP</code> 请求将数据发送到服务器。</li><li><strong>协商和访问控制：</strong> <code>HTTP</code> 请求中包含各种头信息，用于协商浏览器和服务器之间的通信参数，例如浏览器支持的压缩格式、语言偏好、请求的资源类型等。同时，服务器可以通过分析请求头来控制对资源的访问，例如限制某些 <code>IP</code> 地址或用户代理对特定资源的访问。</li></ul><p>“等等，你刚才说 <code>HTTP</code> 请求是一种消息格式，它包含请求行、请求头和请求体？”你疑惑的发问。</p><p>“这个简单。”我微笑道。</p><blockquote><h3 id="http-请求的结构" tabindex="-1"><a class="header-anchor" href="#http-请求的结构"><span>HTTP 请求的结构</span></a></h3></blockquote><p>一个典型的 HTTP 请求由以下部分组成：</p><ul><li><strong>请求行：</strong> 包括请求方法（如 <code>GET、POST、PUT、DELETE</code> 等）、请求 <code>URL</code> 和 <code>HTTP</code> 协议版本（如 <code>HTTP/1.1</code> 或 <code>HTTP/2</code>）。例如： <code>GET /index.html HTTP/1.1</code></li><li><strong>请求头：</strong> 包含有关请求的附加信息，如浏览器类型、用户语言、支持的压缩格式等。例如：</li></ul><div class="language-js line-numbers-mode" data-ext="js" data-title="js"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">Host</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> www</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">example</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">com</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">User</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">-</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">Agent</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> Mozilla</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">/</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">5.0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">Windows</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> NT</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 10.0</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">; </span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">Win64</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">; </span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">x64</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">Accept</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">-</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">Language</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> en</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">-</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">US</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">en</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">q</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">0.5</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>请求体：</strong> 用于发送数据，如表单数据或上传的文件。对于 GET 请求，请求体通常是空的。</li></ul><blockquote><h3 id="常用-http-请求方法" tabindex="-1"><a class="header-anchor" href="#常用-http-请求方法"><span>常用 HTTP 请求方法</span></a></h3></blockquote><ul><li>GET： 请求获取指定资源的内容。</li><li>POST： 向服务器提交数据，通常是表单数据或上传的文件。</li><li>PUT： 用于更新或替换指定资源的内容。</li><li>DELETE： 请求删除指定资源。</li></ul><blockquote><h3 id="浏览器发送-http-请求的过程" tabindex="-1"><a class="header-anchor" href="#浏览器发送-http-请求的过程"><span>浏览器发送 HTTP 请求的过程</span></a></h3></blockquote><p><strong>当浏览器需要获取资源时，会通过以下步骤发送 HTTP 请求：</strong></p><ul><li>如果需要身份验证，浏览器可能会提示用户输入用户名和密码。</li><li>浏览器将请求发送到服务器的端口（通常是 80 或 443）。</li><li>服务器收到请求后，进行处理并返回响应。</li></ul><div class="hint-container tip"><p class="hint-container-title">总结</p><p>HTTP 请求是浏览器与服务器之间通信的重要方式，通过 HTTP 请求，浏览器可以获取资源、发送数据、协商访问控制等，确保用户能够顺利地浏览网页和访问网络上的各种内容。</p></div><h2 id="第四步-服务器响应" tabindex="-1"><a class="header-anchor" href="#第四步-服务器响应"><span>第四步：服务器响应</span></a></h2><blockquote><h3 id="服务器返回响应报文" tabindex="-1"><a class="header-anchor" href="#服务器返回响应报文"><span>服务器返回响应报文</span></a></h3></blockquote><p><strong>在浏览器发送 HTTP 请求后，服务器会返回一个响应报文。响应报文主要包含以下部分：状态码、响应头和资源内容。</strong></p><ul><li>状态码：是一个三位数的代码，用于表示服务器对请求的处理结果。例如：</li></ul><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>200 OK：表示请求成功，服务器已成功处理了请求。</span></span>
<span class="line"><span>404 Not Found：表示请求的资源未找到。</span></span>
<span class="line"><span>500 Internal Server Error：表示服务器内部错误，无法完成请求。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>响应头：包含了服务器返回的元数据，这些元数据提供了关于响应的各种信息，如：</li></ul><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>Content-Type：表示响应的内容类型，例如 text/html 表示 HTML 文档，image/jpeg 表示 JPEG 图像。</span></span>
<span class="line"><span>Content-Length：表示响应内容的长度。</span></span>
<span class="line"><span>Cache-Control：用于控制缓存策略，例如 max-age=3600 表示内容在客户端缓存中可以缓存 1 小时。</span></span>
<span class="line"><span>Date：表示服务器生成响应的时间。</span></span>
<span class="line"><span>Server：表示服务器的软件名称和版本，例如 Apache/2.4.56。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>资源内容：是服务器返回的实际数据，例如 HTML 文档、CSS 文件、JavaScript 文件或图片等。浏览器会根据响应头中的内容类型信息来解析和处理资源内容，从而渲染网页或更新页面内容。</li></ul><div class="hint-container tip"><p class="hint-container-title">总结</p><p>服务器返回HTTP响应报文，其中状态码指示请求处理结果，响应头提供资源元数据，资源内容则是请求的资源本身。</p></div><h2 id="第五步-下载资源" tabindex="-1"><a class="header-anchor" href="#第五步-下载资源"><span>第五步：下载资源</span></a></h2><blockquote><h3 id="浏览器接收-html、css、js、图片等文件" tabindex="-1"><a class="header-anchor" href="#浏览器接收-html、css、js、图片等文件"><span>浏览器接收 HTML、CSS、JS、图片等文件</span></a></h3></blockquote><ul><li>当浏览器收到服务器返回的 <code>HTML</code> 文件后，会开始解析 <code>HTML</code> 内容。</li><li>在解析过程中，浏览器会发现 <code>HTML</code> 中引用了其他资源，如 <code>CSS</code> 文件、<code>JavaScript</code> 文件、图片等。</li><li>接下来，浏览器会根据这些资源的 <code>URL</code>，再次通过 <code>HTTP</code> 请求从服务器下载这些资源。</li></ul><p><strong>具体步骤如下：</strong></p><ul><li>解析HTML ：浏览器解析 <code>HTML</code> 文件，识别出其中的资源引用，如 <code>&lt;link&gt;</code> 标签引用的 <code>CSS</code> 文件、<code>&lt;script&gt;</code> 标签引用的 <code>JavaScript</code> 文件、<code>&lt;img&gt;</code> 标签引用的图片等。</li><li>发起请求 ：对于每个引用的资源，浏览器会再次通过 <code>HTTP</code> 请求从服务器下载这些资源。这些请求通常会包含资源的 <code>URL</code>、请求方法（如 <code>GET</code>）、请求头等信息。</li><li>接收响应 ：服务器收到请求后，会返回相应的资源文件，包括 <code>CSS</code> 文件、<code>JavaScript</code> 文件、图片等。响应中会包含状态码、响应头和资源内容。</li><li>缓存处理 ：浏览器会根据响应头中的缓存控制信息（如 <code>Cache-Control</code>）决定是否缓存这些资源。如果资源可以缓存，浏览器会在本地存储这些资源，以便下次访问时可以直接使用缓存，减少网络请求。</li><li>加载资源 ：浏览器将下载的资源加载到内存中，准备进行后续的渲染操作。例如，<code>CSS</code> 文件用于设置页面的样式，<code>JavaScript</code> 文件用于实现页面的交互功能，图片用于显示图像内容等。</li></ul><div class="hint-container tip"><p class="hint-container-title">总结</p><p>下载资源是浏览器渲染网页的重要步骤之一。通过下载 <code>HTML</code>、<code>CSS</code>、<code>JavaScript</code>、图片等文件，浏览器能够获取到网页所需的所有资源，为后续的解析、构建 DOM 树、执行 <code>JavaScript</code>、生成渲染树、布局和绘制等步骤打下基础。</p></div>`,77)]))}const c=s(n,[["render",l],["__file","index.html.vue"]]),p=JSON.parse('{"path":"/article/jsjlxf7n/","title":"浏览器渲染原理（上）","lang":"zh-CN","frontmatter":{"title":"浏览器渲染原理（上）","createTime":"2025/02/8 17:01:33","permalink":"/article/jsjlxf7n/","tags":["浏览器"]},"headers":[],"readingTime":{"minutes":11.63,"words":3488},"git":{"updatedTime":1739373983000,"contributors":[{"name":"Jokul482","username":"Jokul482","email":"849610435@qq.com","commits":1,"avatar":"https://avatars.githubusercontent.com/Jokul482?v=4","url":"https://github.com/Jokul482"}]},"filePathRelative":"前端开发/工具/浏览器渲染原理.md","categoryList":[{"id":"0ffed7","sort":10001,"name":"前端开发"},{"id":"e35e4d","sort":10002,"name":"工具"}]}');export{c as comp,p as data};
